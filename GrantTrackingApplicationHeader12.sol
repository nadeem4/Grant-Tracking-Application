pragma solidity ^0.4.25;

import './GrantTrackingApplicationLine12.sol';

contract GrantTrackingApplicationHeader12 {

    GrantTrackingApplicationLine12 grantTrackingApplicationLine;
    address public Goverment;
    address public Recipient;
    address public flowUser;
    uint public id;
    uint public parentContractId = 0;
    
    enum StateType {
        Requested,
        Approved,
        Funded,
        ReportingRequired,
        Compliant,
        OutOfCompliance,
        GrantRequestedFromRecipient,
        Closed
    } 
    
    StateType public State;

    mapping(uint => uint) grantApprovedMapping; // contains a mapping of grantTrackingApplication and the grant approved agains this contract
    mapping(address => bool) recipientIsComplainceMapping; // contains a mapping of recipient and whether recipinet is in complaince or not
    mapping(uint => GrantTrackingApplicationLine12) grantTrackingLineContractIdMapping; // contains a mapping of id generated by main contract and new contract 
    mapping(uint => address) grantTrackingLineRequestedFromMapping; // contains mapping of grant Line and Requested from Recipient
    mapping(uint => address) grantTrackingLineRecipientMapping; // contains mapping of grant Line and Recipient
    mapping(uint => bool) grantTrackingApplicationIsComplainceMapping; // contains a mapping of grantTracking contract and isComplaince State
    mapping(uint => uint) grantMoneyLeftMapping; // contains mapping for grant money left in contract
    mapping(uint => bool) grantTrackingApplicationClosed; // contains mapping of grant tracking application and closed state

    address[] recipientArr; // contains all the involved recipient address
    uint[] public contractIds;
    uint[] public approvedContractIds;
    uint[] public outOfComplinaceContractIds;
    uint[] public inComplinaceContractIds;
    uint[] public closedContractIds;
    uint public grantRequested;
    uint public reportingPeriod;
    uint public gracePeriod;
    uint public grantApproved;
    uint public grantRemaining;
    string public fileUrl;

    modifier onlyRequestedFromCanTakeAction( uint _contractId) {
        require(grantTrackingLineRequestedFromMapping[_contractId]  == msg.sender, 'Action can only taken by person, from whom grant is requested');
        _;
    }

    modifier onlyPerformedByLegitRecipient( uint _contractId, address _recipinet) {
        require(grantTrackingLineRecipientMapping[_contractId]  == _recipinet, 'Action can only be taken by recipient of contract');
        _;
    }

    modifier canBeReportedByRecipientOrFlowUser( uint _contractId, address _recipinet) {
        require(grantTrackingLineRecipientMapping[_contractId]  == _recipinet || flowUser == msg.sender, 'Action can only be taken by recipient of contract, or flowUser');
        _;
    }
 
    modifier contractShouldBeActive() {
        require(State != StateType.Closed, 'Header Contract is closed, no further action can be taken');
        _;
    }

    constructor( uint _grantRequested, address _goverment, string _fileUrl ) public {
        Goverment = _goverment;
        Recipient = msg.sender;
        fileUrl = _fileUrl;
       // recipientArr.push(msg.sender);
        id = random();
        grantRequested = _grantRequested;
       // grantTrackingLineContractIdMapping[id] = this; // assign  Contract
        grantTrackingLineRequestedFromMapping[id] = _goverment; // assign requestedFrom Contract
        grantTrackingLineRecipientMapping[id] = msg.sender; //assign recipinet to contract
        State = StateType.Requested;
    }

    function requestGrant( uint _grantRequested, address _requestedFrom, uint _parentContractId, string _fileUrl ) 
        public  contractShouldBeActive{
            require(grantTrackingApplicationIsComplainceMapping[_parentContractId] == true, 'Recipinet is not in complaince from whom grant is requested');
            require(grantMoneyLeftMapping[_parentContractId] >= _grantRequested, 'You requesting more grant than Application has left');
            require(grantTrackingLineRecipientMapping[_parentContractId] != msg.sender, 'Recipient cannot request fund from his contract');
            uint contractId = random() ;// generate random contract ID for child contract
            if(_parentContractId != 0 && _parentContractId != id) { // request from header contract
                grantTrackingLineContractIdMapping[_parentContractId].requestGrant();
            } else {
                State = StateType.GrantRequestedFromRecipient;
            }
            //recipientArr.push(msg.sender);

            grantTrackingApplicationLine = new GrantTrackingApplicationLine12(_grantRequested, _requestedFrom, contractId, _parentContractId, this, msg.sender, _fileUrl);
            contractIds.push(contractId); // push requestedContractId
            grantTrackingLineContractIdMapping[contractId] = grantTrackingApplicationLine; // assign one id to each line contract for tracking purpose
            grantTrackingLineRequestedFromMapping[contractId] = _requestedFrom; // assign requestedfrom param to contract
            grantTrackingLineRecipientMapping[contractId] = msg.sender; // assign recipient to contract
    }

    function approveGrant( uint _grantApproved, uint _contractId, uint _parnetContractId ) 
        public onlyRequestedFromCanTakeAction(_contractId) contractShouldBeActive {
        
            grantTrackingApplicationIsComplainceMapping[_contractId] = true; // set contractId to compliance state as soon as grant is approved for that contract
            grantApprovedMapping[_contractId] = _grantApproved; //assign the approved grant to contract grant Approved mapping
            grantMoneyLeftMapping[_contractId] = _grantApproved; //assign the approved grant to contract  grant remaining mapping
            


            if( _contractId == id &&  _parnetContractId == 0 ) { // contract getting approved is header contract and it has no parent
                grantApproved = _grantApproved;
                grantRemaining = _grantApproved;
                State = StateType.Approved;
            } else if( _parnetContractId == id ) { // contract getting approved is child of header contract
                grantRemaining = grantRemaining - _grantApproved;
                grantTrackingLineContractIdMapping[_contractId].approveGrant(_grantApproved);
                approvedContractIds.push(_contractId);
                grantTrackingApplicationClosed[_contractId] = false;
            } 
            else {
                grantMoneyLeftMapping[_parnetContractId] =  grantTrackingLineContractIdMapping[_parnetContractId].deductMoneyFromParentContract(_grantApproved);  // calculate the money left in parent contract
                grantTrackingApplicationClosed[_contractId] = false;
                if( grantMoneyLeftMapping[_parnetContractId] == 0 ) { // check is all grant money is consumed from parent contract, if yes, then close the parent contract
                    grantTrackingLineContractIdMapping[_parnetContractId].close();
                    grantTrackingApplicationClosed[_parnetContractId] = true;
                    closedContractIds.push(_parnetContractId);
                }
                grantTrackingLineContractIdMapping[_contractId].approveGrant(_grantApproved);
                approvedContractIds.push(_contractId);
            }
    }

    function grantFund( uint _reportingPeriod, uint _gracePeriod, uint _contractId, address _recipient) 
        public onlyPerformedByLegitRecipient(_contractId, _recipient) onlyRequestedFromCanTakeAction(_contractId) contractShouldBeActive {

            if(_contractId == id) {
                reportingPeriod = _reportingPeriod;
                gracePeriod = _gracePeriod;
                State = StateType.Funded;
            }  else {
                grantTrackingLineContractIdMapping[_contractId].grantFund(_reportingPeriod, _gracePeriod);
            }
        
    }

    function requireReporting( uint _contractId )  public contractShouldBeActive{
        flowUser = msg.sender;
        if(_contractId == id) {
            State = StateType.ReportingRequired;
        } else {
            grantTrackingLineContractIdMapping[_contractId].requireReporting();
        }
        
    }

    function report( bool _isTriggeredByRecipient, bool _isTriggeredByFlow, uint _grantTransferred, uint _grantUsed, uint _contractId) 
        public canBeReportedByRecipientOrFlowUser(_contractId, msg.sender) contractShouldBeActive {
        
            bool isInComplinace = false;
            bool isAllContractAreClosed = false;

            // check if reproting is done by user or flow, if done done by user then add true boolean in header for that contract, otherwiese add false boolean
            if(_isTriggeredByRecipient) { 
                grantTrackingApplicationIsComplainceMapping[_contractId] = true;
            } else if(_isTriggeredByFlow) {
                grantTrackingApplicationIsComplainceMapping[_contractId] = false;
            }

            // calucate remaining grant based on what ever is used by recipient
            if(_contractId == id) {
                grantRemaining = grantRemaining - _grantUsed;
            } else {
                grantMoneyLeftMapping[_contractId] =  grantTrackingLineContractIdMapping[_contractId].deductMoneyFromParentContract(_grantUsed);  // calculate the money left in parent contract
            
                if( grantMoneyLeftMapping[_contractId] == 0 ) { // check is all grant money is consumed from parent contract, if yes, then close the parent contract
                    grantTrackingLineContractIdMapping[_contractId].close();
                    grantTrackingApplicationClosed[_contractId] = true;
                    closedContractIds.push(_contractId);
                }
                grantTrackingLineContractIdMapping[_contractId].report(_isTriggeredByRecipient, _isTriggeredByFlow, _grantTransferred, _grantUsed);
            }

            if( _contractId == id && contractIds.length == 0) { // contractIds.length == 0 is added to prevent someone manually passing parent contract Id and changing its state to compliance
                //State = StateType.Reported;
                if( _isTriggeredByRecipient ) {
                    State = StateType.Compliant;
                } else if( _isTriggeredByFlow ) {
                    State = StateType.OutOfCompliance;
                }
            } else {
                isInComplinace = isAllChildContractsAreInComplainceState(approvedContractIds); // check whether all child contract are compliant or not,  if yes then chnage the header state to incomplaince
                if(isInComplinace) {
                    State = StateType.Compliant;
                } else {
                    State = StateType.OutOfCompliance;
                }
                
            }

            isAllContractAreClosed = checkIfAllGrantMoneyConsumed(approvedContractIds);

            if(isAllContractAreClosed && grantRemaining == 0) {
                close();
            }
        
    }

    //generate a random number to generate contract ids for child contracts
    function random() private view returns (uint) {
        return (uint256(keccak256(block.timestamp, block.difficulty))%251);
    }

    function close() public {
        State = StateType.Closed;
    }
    //check whether all approved child contract are in complaince or not
    function isAllChildContractsAreInComplainceState( uint[] _approvedChildContractArr) private view returns  (bool){
       // uint[] memory tempInComplianceContract;
        //uint[] memory tempOutOfComplianceContract;
        for( uint i = 0; i < _approvedChildContractArr.length; i++ ) {
            if( !grantTrackingApplicationIsComplainceMapping[ _approvedChildContractArr[i] ] ) {
                return false;
              //  tempInComplianceContract.push(_approvedChildContractArr[i]);
            } 
        }
        return true;
        /* outOfComplinaceContractIds = tempOutOfComplianceContract;
        inComplinaceContractIds = tempInComplianceContract;
        if(tempOutOfComplianceContract.length == 0) {
            return true;
        } else {
            ret urn false;
        }*/
    }

    //check if all grant money is consumed
    function checkIfAllGrantMoneyConsumed(uint[] _approvedChildContractArr) private view returns (bool) {
        for( uint i = 0; i < _approvedChildContractArr.length; i++ ) {
            if(!grantTrackingApplicationClosed[ _approvedChildContractArr[i] ]) {
                return false;
            }
        }
        return true;
    }

    

    function GetcontractIds() public constant  returns (uint []) {
        return contractIds;
    }
    function GetapprovedContractIds() public constant  returns (uint []) {
        return approvedContractIds;
    }
    function GetoutOfComplinaceContractIds() public constant  returns (uint []) {
        return outOfComplinaceContractIds;
    }
    function GetinComplinaceContractIds() public constant  returns (uint []) {
        return inComplinaceContractIds;
    }
    function GetclosedContractIds() public constant  returns (uint []) {
        return closedContractIds;
    }
}